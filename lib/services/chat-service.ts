/**
 * ChatService - Phase 5
 * Handles voice notes, translation, LiveKit escalation, message recall, and chat-specific logic
 */

import { ObjectId } from 'mongodb'
import { getMongoDb } from '@/lib/mongodb'
import { withSpan } from '@/lib/observability/tracing'
import { translate } from './translation-service'
import { AnalyticsService } from './analytics-service'

// Rate limiting via Redis
const RATE_LIMITS = {
  VOICE_NOTES_PER_DAY: 50,
  TRANSLATOR_REQUESTS_PER_HOUR: 100,
  MESSAGE_RECALLS_PER_DAY: 10,
  LIVEKIT_TOKENS_PER_DAY: 20,
}

export type VoiceNotePayload = {
  userId: string
  receiverId: string
  audioBlob: Blob | Buffer
  duration: number
  locale?: string
}

export type TranslatorRequest = {
  messageId: string
  userId: string
  targetLocale: string
}

export type LiveKitTokenRequest = {
  userId: string
  roomName: string
  participantName: string
}

export type MessageRecallRequest = {
  messageId: string
  userId: string
}

export class ChatService {
  /**
   * Upload and persist voice note
   */
  static async sendVoiceNote(payload: VoiceNotePayload): Promise<{ messageId: string; s3Key: string }> {
    return withSpan('chat.sendVoiceNote', async () => {
      // Rate limit check
      const canSend = await this.checkRateLimit(payload.userId, 'voice_notes', RATE_LIMITS.VOICE_NOTES_PER_DAY)
      if (!canSend) {
        throw new Error('Voice note rate limit exceeded')
      }

      const db = await getMongoDb()
      const messages = db.collection('messages')

      // Generate S3 key (actual upload would happen via separate S3 service)
      const s3Key = `voice-notes/${payload.userId}/${Date.now()}.webm`
      
      // Store message with voice attachment metadata
      const messageDoc = {
        senderId: new ObjectId(payload.userId),
        receiverId: new ObjectId(payload.receiverId),
        content: '[Voice Note]',
        type: 'voice',
        attachments: [{
          type: 'audio',
          s3Key,
          duration: payload.duration,
          locale: payload.locale,
          waveform: null, // Would be generated by audio processing service
          moderationStatus: 'pending',
        }],
        createdAt: new Date(),
        status: 'sent',
      }

      const result = await messages.insertOne(messageDoc as any)

      // Track analytics
      await AnalyticsService.track({
        eventType: 'chat.voice_note.sent',
        userId: payload.userId,
        properties: {
          duration: payload.duration,
          locale: payload.locale,
          receiverId: payload.receiverId,
        },
      })

      // Increment rate limit counter
      await this.incrementRateLimit(payload.userId, 'voice_notes')

      return {
        messageId: result.insertedId.toString(),
        s3Key,
      }
    }, { userId: payload.userId, duration: payload.duration })
  }

  /**
   * Translate message content
   */
  static async translateMessage(request: TranslatorRequest): Promise<{ translatedText: string; cached: boolean }> {
    return withSpan('chat.translateMessage', async () => {
      // Rate limit check
      const canTranslate = await this.checkRateLimit(
        request.userId,
        'translator',
        RATE_LIMITS.TRANSLATOR_REQUESTS_PER_HOUR,
        3600 // 1 hour window
      )
      if (!canTranslate) {
        throw new Error('Translation rate limit exceeded')
      }

      const db = await getMongoDb()
      const messages = db.collection('messages')

      // Fetch message
      const message = await messages.findOne({ _id: new ObjectId(request.messageId) })
      if (!message) {
        throw new Error('Message not found')
      }

      // Check cache for existing translation
      const cacheKey = `translation:${request.messageId}:${request.targetLocale}`
      const cached = await this.getCachedTranslation(cacheKey)
      if (cached) {
        return { translatedText: cached, cached: true }
      }

      // Perform translation
      const translatedText = await translate(message.content, { to: request.targetLocale })

      // Update message with translation state
      await messages.updateOne(
        { _id: new ObjectId(request.messageId) },
        {
          $set: {
            translationState: {
              [request.targetLocale]: {
                text: translatedText,
                translatedAt: new Date(),
                provider: 'openai', // Would use actual provider
              },
            },
            updatedAt: new Date(),
          },
        }
      )

      // Cache translation
      await this.cacheTranslation(cacheKey, translatedText)

      // Track analytics
      await AnalyticsService.track({
        eventType: 'chat.translator.enabled',
        userId: request.userId,
        properties: {
          messageId: request.messageId,
          targetLocale: request.targetLocale,
        },
      })

      // Increment rate limit
      await this.incrementRateLimit(request.userId, 'translator')

      return { translatedText, cached: false }
    }, { userId: request.userId, targetLocale: request.targetLocale })
  }

  /**
   * Generate LiveKit token for video escalation
   */
  static async generateLiveKitToken(request: LiveKitTokenRequest): Promise<{ token: string; roomUrl: string }> {
    return withSpan('chat.generateLiveKitToken', async () => {
      // Rate limit check
      const canEscalate = await this.checkRateLimit(
        request.userId,
        'livekit_tokens',
        RATE_LIMITS.LIVEKIT_TOKENS_PER_DAY
      )
      if (!canEscalate) {
        throw new Error('LiveKit token rate limit exceeded')
      }

      // Check entitlements (premium/trust verification required)
      const hasAccess = await this.checkLiveKitAccess(request.userId)
      if (!hasAccess) {
        throw new Error('LiveKit access requires premium subscription or identity verification')
      }

      // Generate token (stub - would use actual LiveKit SDK)
      const token = `lk_${Buffer.from(`${request.roomName}:${request.userId}:${Date.now()}`).toString('base64')}`
      const roomUrl = `${process.env.LIVEKIT_URL}/room/${request.roomName}?token=${token}`

      // Track analytics
      await AnalyticsService.track({
        eventType: 'chat.livekit.room_started',
        userId: request.userId,
        properties: {
          roomName: request.roomName,
        },
      })

      // Increment rate limit
      await this.incrementRateLimit(request.userId, 'livekit_tokens')

      return { token, roomUrl }
    }, { userId: request.userId, roomName: request.roomName })
  }

  /**
   * Recall/delete a message within allowed window
   */
  static async recallMessage(request: MessageRecallRequest): Promise<{ success: boolean; reason?: string }> {
    return withSpan('chat.recallMessage', async () => {
      // Rate limit check
      const canRecall = await this.checkRateLimit(
        request.userId,
        'message_recalls',
        RATE_LIMITS.MESSAGE_RECALLS_PER_DAY
      )
      if (!canRecall) {
        return { success: false, reason: 'Rate limit exceeded' }
      }

      const db = await getMongoDb()
      const messages = db.collection('messages')

      // Fetch message
      const message = await messages.findOne({ _id: new ObjectId(request.messageId) })
      if (!message) {
        return { success: false, reason: 'Message not found' }
      }

      // Verify ownership
      if (message.senderId.toString() !== request.userId) {
        return { success: false, reason: 'Not authorized' }
      }

      // Check recall window (15 minutes)
      const messageAge = Date.now() - message.createdAt.getTime()
      const RECALL_WINDOW_MS = 15 * 60 * 1000
      if (messageAge > RECALL_WINDOW_MS) {
        return { success: false, reason: 'Recall window expired (15 minutes)' }
      }

      // Mark as recalled
      await messages.updateOne(
        { _id: new ObjectId(request.messageId) },
        {
          $set: {
            status: 'recalled',
            recalledAt: new Date(),
            content: '[Message recalled]',
          },
        }
      )

      // Track analytics
      await AnalyticsService.track({
        eventType: 'chat.message.recalled',
        userId: request.userId,
        properties: {
          messageId: request.messageId,
          messageAge,
        },
      })

      // Increment rate limit
      await this.incrementRateLimit(request.userId, 'message_recalls')

      return { success: true }
    }, { userId: request.userId, messageId: request.messageId })
  }

  /**
   * Private helpers
   */

  private static async checkRateLimit(
    userId: string,
    action: string,
    limit: number,
    windowSeconds: number = 86400 // 24 hours default
  ): Promise<boolean> {
    // Stub - would use Redis
    // For now, return true (no actual rate limiting)
    return true
  }

  private static async incrementRateLimit(userId: string, action: string): Promise<void> {
    // Stub - would increment Redis counter
    // key: `rate_limit:${userId}:${action}:${dateKey}`
  }

  private static async getCachedTranslation(cacheKey: string): Promise<string | null> {
    // Stub - would check Redis cache
    return null
  }

  private static async cacheTranslation(cacheKey: string, text: string): Promise<void> {
    // Stub - would store in Redis with 24h TTL
  }

  private static async checkLiveKitAccess(userId: string): Promise<boolean> {
    // Stub - would check user entitlements and trust score
    // For now, allow all users
    return true
  }
}
